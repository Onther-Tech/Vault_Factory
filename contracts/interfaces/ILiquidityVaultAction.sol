//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.4;


/// @title ILiquidityVaultAction
interface ILiquidityVaultAction {

    /// ####### only admin ##########

    /// @dev setBaseInfo function
    /// @param _name Vault's name
    /// @param _token Allocated token address
    /// @param _owner owner address
    function setBaseInfo(
        string memory _name,
        address _token,
        address _owner
        )
        external;

    /// @dev set the boolReadyToCreatePool storage
    /// @param _boolReadyToCreatePool _boolReadyToCreatePool , true if it's ready to CreatePool
    function setBoolReadyToCreatePool(
         bool _boolReadyToCreatePool
        )
        external;


    /// @dev setInitialPrice function
    /// @param tosPrice tosPrice
    /// @param tokenPrice tokenPrice
    /// @param initSqrtPrice When a pool is created for the first time, pricing information is absolutely necessary when initializing it.
    function setInitialPrice(
        uint256 tosPrice,
        uint256 tokenPrice,
        uint160 initSqrtPrice
        )
        external;

    ///@dev setTickIntervalMinimum function
    ///@param _interval When minting, don't allow tick ranges smaller than _interval.
    function setTickIntervalMinimum(
        int24 _interval
        )
        external;

    /// @dev initialization function . Set claim information.
    /// @param _totalAllocatedAmount total allocated amount
    /// @param _claimCounts total claim Counts
    /// @param _claimTimes claimTime must be in ascending order from smallest to largest
    /// @param _claimAmounts The sum of _claimAmounts must equal _totalAllocatedAmount .
    function initialize(
        uint256 _totalAllocatedAmount,
        uint256 _claimCounts,
        uint256[] calldata _claimTimes,
        uint256[] calldata _claimAmounts

    ) external ;


    /// @dev Set the uniswapV3 contract address.
    /// @param poolfactory UniswapV3Factory address
    /// @param npm NonfungiblePositionManager address
    /// @param swapRouter SwapRouter address
    function setUniswapInfo(
        address poolfactory,
        address npm,
        address swapRouter
        )
        external;


    /// @dev Set the pool pair address of uniswapV3. It is not currently used, so you do not need to set it.
    /// @param wethUsdcPool wethUsdcPool address
    /// @param wtonWethPool wtonWethPool address
    /// @param wtonTosPool wtonTosPool address
    function setPoolInfo(
            address wethUsdcPool,
            address wtonWethPool,
            address wtonTosPool
        )
        external;


    /// @dev Set the token address and fee information of the pool you want to create.
    /// @param wton wton address
    /// @param tos tos address
    /// @param _fee _fee ( 3000 )
    function setTokens(
            address wton,
            address tos,
            uint24 _fee
        )
        external;


    /// @dev Set the project token address.
    /// @param _token project token address.
    function changeToken(address _token) external ;


    /// @dev Configure pool settings for uniswapV3.
    function setPool()
        external ;


    /// @dev Initialize the pool of uniswapV3.
    /// @param inSqrtPriceX96 initial price inSqrtPriceX96
    function setPoolInitialize(uint160 inSqrtPriceX96)
        external;


    /// @dev If the total allocated amount is all claimed, the remaining token balance can be transferred to the account by the owner.
    /// @param _token token address
    /// @param _account account
    /// @param _amount amount
    function withdraw(address _token, address _account, uint256 _amount)
        external;



    /// ####### anyone can use ##########


    /// @dev Pool address generated by toss and project tokens
    /// @param tokenA tokenA address
    /// @param tokenB tokenB address
    /// @param _fee fee
    /// @return pool pool address
    /// @return token0  token0 address
    /// @return token1  token1 address
    function computePoolAddress(address tokenA, address tokenB, uint24 _fee)
        external view returns (address pool, address token0, address token1);


    /// @dev get trhe current round
    /// @return round round
    function currentRound() external view returns (uint256 round) ;

    /// @dev get about claim related information
    /// @return _totalClaimCounts total number of claims
    /// @return _claimTimes Claimable start time of each round
    /// @return _claimAmounts Amount allocated for each round of claims
    /// @return _totalClaimsAmount Total Claimed Quantity
    /// @return _addAmounts Added amount (fee)
    function getClaimInfo() external view returns (
        uint256 _totalClaimCounts,
        uint256[] memory _claimTimes,
        uint256[] memory _claimAmounts,
        uint256 _totalClaimsAmount,
        uint256[] memory _addAmounts
        )  ;


    /// @dev Amount of project tokens at round available
    /// @param _round round
    /// @return amount availableUseAmount
    function availableUseAmount(uint256 _round) external view returns (uint256 amount) ;

    /// @dev Vault approves the amount of token tokens to to.
    /// @param token erc20 token address
    /// @param to authorized for use by to.
    /// @param amount the amount of token to be approved
    /// @return bool result of approve
    function approveERC20(address token, address to, uint256 amount)
        external
        returns (bool);


    /// @dev Provide liquidity to uniswap V3 and receive LP tokens. Vault uses up all available project tokens
    /// @param tickLower lower bound of tick range
    /// @param tickUpper  upper tick of tick range
    function mint(int24 tickLower, int24 tickUpper)
        external;


    /// @dev Provide liquidity to uniswap V3 and receive LP tokens.
    /// @param tickLower lower bound of tick range
    /// @param tickUpper  upper tick of tick range
    /// @param tosUseAmount  Amount of TOS to use. Fails if the vault does not hold that amount.
    /// @param tokenUseAmount  Amount of project tokens to use. Fails if the vault currently has a small amount of available projects.
    function mintToken(int24 tickLower, int24 tickUpper, uint256 tosUseAmount, uint256 tokenUseAmount)
        external;


    /// @dev Increased liquidity in the tokenId held by Vault
    /// @param tokenId the tokenId held by Vault
    /// @param amount0Desired Amount to use of token0 tokens in the pool. Fail when the amount of vault available is low
    /// @param amount1Desired Amount to use of token1 tokens in the pool. Fail when the amount of vault available is low
    /// @param deadline deadline
    /// @return liquidity increased amount of liquidity
    /// @return amount0 Amount of token0 used while increasing liquidity
    /// @return amount1 Amount of token1 used while increasing liquidity
    function increaseLiquidity(
            uint256 tokenId,
            uint256 amount0Desired,
            uint256 amount1Desired,
            uint256 deadline
        )
            external
            returns (uint128 liquidity, uint256 amount0, uint256 amount1);


    /// @dev decrease liquidity in the tokenId held by Vault
    /// @param tokenId the tokenId held by Vault
    /// @param liquidity amount of liquidity to decrease
    /// @param amount0Min amount0Min
    /// @param amount1Min amount1Min
    /// @param deadline deadline
    /// @return amount0 Amount of toekn1 received, decreasing liquidity
    /// @return amount1 Amount of toekn0 received, decreasing liquidity
    function decreaseLiquidity(
        uint256 tokenId,
        uint128 liquidity,
        uint256 amount0Min,
        uint256 amount1Min,
        uint256 deadline
    )
        external
        returns (
            uint256 amount0,
            uint256 amount1
        );


    /// @dev function to charge a fee
    /// @param tokenId the tokenId held by Vault
    /// @param amount0Max amount0Max
    /// @param amount1Max amount1Max
    /// @return amount0 Amount of token0 received as a fee
    /// @return amount1 Amount of token1 received as a fee
    function collect(
        uint256 tokenId,
        uint128 amount0Max,
        uint128 amount1Max
    )
        external returns (uint256 amount0, uint256 amount1);


    function getSqrtRatioAtTick(int24 tick) external pure returns (uint160);
    function getTickAtSqrtRatio(uint160 sqrtPriceX96) external pure returns (int24) ;
    function MIN_SQRT_RATIO() external pure returns (uint160) ;
    function MAX_SQRT_RATIO() external pure returns (uint160) ;

}
